
STRLCPY(3)               BSD Library Functions Manual               STRLCPY(3)

NNAAMMEE
     ssttrrllccppyy, ssttrrllccaatt -- size-bounded string copying and concatenation

LLIIBBRRAARRYY
     Standard C Library (libc, -lc)

SSYYNNOOPPSSIISS
     ##iinncclluuddee <<ssttrriinngg..hh>>

     _s_i_z_e___t
     ssttrrllccppyy(_c_h_a_r _* _r_e_s_t_r_i_c_t _d_s_t, _c_o_n_s_t _c_h_a_r _* _r_e_s_t_r_i_c_t _s_r_c, _s_i_z_e___t _d_s_t_s_i_z_e);

     _s_i_z_e___t
     ssttrrllccaatt(_c_h_a_r _* _r_e_s_t_r_i_c_t _d_s_t, _c_o_n_s_t _c_h_a_r _* _r_e_s_t_r_i_c_t _s_r_c, _s_i_z_e___t _d_s_t_s_i_z_e);

DDEESSCCRRIIPPTTIIOONN
     The ssttrrllccppyy() and ssttrrllccaatt() functions copy and concatenate strings with
     the same input parameters and output result as snprintf(3).  They are
     designed to be safer, more consistent, and less error prone replacements
     for the easily misused functions strncpy(3) and strncat(3).

     ssttrrllccppyy() and ssttrrllccaatt() take the full size of the destination buffer and
     guarantee NUL-termination if there is room.  Note that room for the NUL
     should be included in _d_s_t_s_i_z_e.

     ssttrrllccppyy() copies up to _d_s_t_s_i_z_e - 1 characters from the string _s_r_c to _d_s_t,
     NUL-terminating the result if _d_s_t_s_i_z_e is not 0.

     ssttrrllccaatt() appends string _s_r_c to the end of _d_s_t.  It will append at most
     _d_s_t_s_i_z_e - strlen(dst) - 1 characters.  It will then NUL-terminate, unless
     _d_s_t_s_i_z_e is 0 or the original _d_s_t string was longer than _d_s_t_s_i_z_e (in prac-
     tice this should not happen as it means that either _d_s_t_s_i_z_e is incorrect
     or that _d_s_t is not a proper string).

     If the _s_r_c and _d_s_t strings overlap, the behavior is undefined.

RREETTUURRNN VVAALLUUEESS
     Besides quibbles over the return type (_s_i_z_e___t versus _i_n_t) and signal han-
     dler safety (snprintf(3) is not entirely safe on some systems), the fol-
     lowing two are equivalent:

           n = strlcpy(dst, src, len);
           n = snprintf(dst, len, "%s", src);

     Like snprintf(3), the ssttrrllccppyy() and ssttrrllccaatt() functions return the total
     length of the string they tried to create.  For ssttrrllccppyy() that means the
     length of _s_r_c.  For ssttrrllccaatt() that means the initial length of _d_s_t plus
     the length of _s_r_c.

     If the return value is >>== _d_s_t_s_i_z_e, the output string has been truncated.
     It is the caller's responsibility to handle this.

EEXXAAMMPPLLEESS
     The following code fragment illustrates the simple case:

           char *s, *p, buf[BUFSIZ];

           ...

           (void)strlcpy(buf, s, sizeof(buf));
           (void)strlcat(buf, p, sizeof(buf));

     To detect truncation, perhaps while building a pathname, something like
     the following might be used:

           char *dir, *file, pname[MAXPATHLEN];

           ...

           if (strlcpy(pname, dir, sizeof(pname)) >= sizeof(pname))
                   goto toolong;
           if (strlcat(pname, file, sizeof(pname)) >= sizeof(pname))
                   goto toolong;

     Since it is known how many characters were copied the first time, things
     can be sped up a bit by using a copy instead of an append:

           char *dir, *file, pname[MAXPATHLEN];
           size_t n;

           ...

           n = strlcpy(pname, dir, sizeof(pname));
           if (n >= sizeof(pname))
                   goto toolong;
           if (strlcpy(pname + n, file, sizeof(pname) - n) >= sizeof(pname) - n)
                   goto toolong;

     However, one may question the validity of such optimizations, as they
     defeat the whole purpose of ssttrrllccppyy() and ssttrrllccaatt().  As a matter of
     fact, the first version of this manual page got it wrong.

SSEEEE AALLSSOO
     snprintf(3), strncat(3), strncpy(3), wcslcpy(3)

HHIISSTTOORRYY
     The ssttrrllccppyy() and ssttrrllccaatt() functions first appeared in OpenBSD 2.4, and
     FreeBSD 3.3.

BSD                            February 26, 2016                           BSD
